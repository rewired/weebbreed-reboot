# Data and Blueprints [ # Source: docs/backend-overview.md § 3. Blueprints Provided & How to Use Them; docs/system/data-validation.md § Blueprint Data Validation Workflow; docs/DD.md § Conventions (apply to all files) ]

- **Blueprint Doctrine.** Blueprints are delivered with the new repo as a validated collection spanning structures, room purposes, cultivation methods, strains, devices, pests, diseases, personnel roles, and price maps; they are immutable templates, never instantiated directly, because runtime systems always materialise instances by copying a blueprint, which enables multiple simultaneous instances—such as many small warehouses, rooms, or zones—from the same template without mutating the source data.【F:docs/backend-overview.md†L40-L52】
- **Schema conventions.** All blueprints follow shared rules: UUID `id` keys, camelCase naming without unit suffixes, SI units for physical quantities, inclusive ranges, and validation that enforces required fields, numeric bounds, and cross-references before runtime use.【F:docs/DD.md†L1-L41】【F:docs/backend-overview.md†L46-L52】【F:docs/backend-overview.md†L123-L139】
- **Validation workflow.** The `pnpm validate:data` command parses each blueprint family, enforces casing-sensitive control setpoints, emits machine- and human-readable reports, and fails CI when errors appear, ensuring data drift is caught before integration.【F:docs/system/data-validation.md†L1-L53】
- **Materialisation pipeline.** Loading blueprints involves validation, copying template values into runtime records, resolving cross-map identifiers (e.g., price tables), and exposing read-only instances to subsystems so deterministic state changes never mutate source JSON.【F:docs/backend-overview.md†L123-L129】
