import type { EnhancedStrainBlueprint, EnvMetric } from '../strains/enhancedStrainInterface.js';\nimport type { CultivationMethodBlueprint } from '@/data/schemas/cultivationMethodSchema.js';\nimport { getEnvBand, mapStageToPhase } from '../strains/enhancedStrainInterface.js';\nimport type { PlantStage } from '@/state/models.js';\n\nexport interface MethodCompatibilityResult {\n  overallScore: number;\n  category: 'excellent' | 'good' | 'acceptable' | 'poor' | 'incompatible';\n  environmentalFit: number;\n  laborFit: number;\n  capacityFit: number;\n  details: {\n    environmental: Record<EnvMetric, { score: number; bias?: number; strain?: number }>;\n    labor: { methodHours: number; strainTolerance: number };\n    capacity: { methodDensity: number; strainPreference: number };\n  };\n}\n\nexport interface CompatibilityContext {\n  strain: EnhancedStrainBlueprint;\n  method: CultivationMethodBlueprint;\n  stage: PlantStage;\n  roomArea_m2?: number;\n}\n\n/**\n * Service to calculate compatibility between cultivation methods and strains\n * Uses method envBias vs strain environmental bands to compute scores\n */\nexport class MethodCompatibilityService {\n  /**\n   * Calculate overall compatibility between a cultivation method and strain\n   */\n  calculateCompatibility(context: CompatibilityContext): MethodCompatibilityResult {\n    const { strain, method, stage } = context;\n    const phase = mapStageToPhase(stage);\n\n    // Calculate environmental fit using method bias vs strain bands\n    const environmentalFit = this.calculateEnvironmentalFit(strain, method, phase);\n\n    // Calculate labor fit based on method requirements vs strain characteristics\n    const laborFit = this.calculateLaborFit(strain, method);\n\n    // Calculate capacity fit based on method density vs strain characteristics\n    const capacityFit = this.calculateCapacityFit(strain, method);\n\n    // Weighted overall score\n    const weights = {\n      environmental: 0.6, // Environmental fit is most important\n      labor: 0.25, // Labor requirements matter for practicality\n      capacity: 0.15, // Space efficiency is important but secondary\n    };\n\n    const overallScore =\n      environmentalFit.score * weights.environmental +\n      laborFit.score * weights.labor +\n      capacityFit.score * weights.capacity;\n\n    // Categorize the compatibility\n    const category = this.categorizeCompatibility(overallScore);\n\n    return {\n      overallScore,\n      category,\n      environmentalFit: environmentalFit.score,\n      laborFit: laborFit.score,\n      capacityFit: capacityFit.score,\n      details: {\n        environmental: environmentalFit.details,\n        labor: laborFit.details,\n        capacity: capacityFit.details,\n      },\n    };\n  }\n\n  /**\n   * Calculate environmental fit by comparing method bias with strain preferences\n   */\n  private calculateEnvironmentalFit(\n    strain: EnhancedStrainBlueprint,\n    method: CultivationMethodBlueprint,\n    phase: 'seedling' | 'veg' | 'flower' | 'ripening',\n  ): { score: number; details: Record<EnvMetric, { score: number; bias?: number; strain?: number }> } {\n    const envBias = method.envBias || {};\n    const metrics: EnvMetric[] = ['temp_C', 'rh_frac', 'co2_ppm', 'ppfd_umol_m2s', 'vpd_kPa'];\n\n    const details: Record<EnvMetric, { score: number; bias?: number; strain?: number }> = {} as any;\n    const scores: number[] = [];\n\n    for (const metric of metrics) {\n      const methodBias = envBias[metric] || 0;\n      const strainBand = getEnvBand(strain, metric, phase);\n\n      let score = 1.0; // Default to perfect fit if no bias or band\n\n      if (methodBias !== 0 && strainBand) {\n        // Calculate if method bias pushes conditions into strain's preferred range\n        const optimalRange = strainBand.green;\n        const acceptableRange = [strainBand.yellowLow, strainBand.yellowHigh];\n\n        // Simple compatibility scoring:\n        // - Method bias that keeps within optimal range = 1.0\n        // - Method bias that keeps within acceptable range = 0.7\n        // - Method bias that pushes outside acceptable range = 0.3\n\n        // For this simplified calculation, we assume method bias represents\n        // typical offset from neutral conditions\n        if (Math.abs(methodBias) <= (optimalRange[1] - optimalRange[0]) / 4) {\n          score = 1.0; // Bias is small relative to optimal range\n        } else if (Math.abs(methodBias) <= (acceptableRange[1] - acceptableRange[0]) / 2) {\n          score = 0.7; // Bias is moderate but manageable\n        } else {\n          score = 0.3; // Large bias may create incompatibility\n        }\n      }\n\n      details[metric] = {\n        score,\n        bias: methodBias,\n        strain: strainBand ? (strainBand.green[0] + strainBand.green[1]) / 2 : undefined,\n      };\n\n      scores.push(score);\n    }\n\n    // Average environmental fit score\n    const environmentalScore = scores.reduce((sum, s) => sum + s, 0) / scores.length;\n\n    return {\n      score: environmentalScore,\n      details,\n    };\n  }\n\n  /**\n   * Calculate labor fit based on method labor requirements\n   */\n  private calculateLaborFit(\n    strain: EnhancedStrainBlueprint,\n    method: CultivationMethodBlueprint,\n  ): { score: number; details: { methodHours: number; strainTolerance: number } } {\n    const methodHours = method.laborProfile?.hoursPerPlantPerWeek || 0.5;\n\n    // Estimate strain labor tolerance based on resilience and method affinity\n    const strainResilience = strain.generalResilience || 0.7;\n    const methodAffinity = strain.methodAffinity?.[method.id] || 0.5;\n\n    // Higher resilience and method affinity = better tolerance for labor-intensive methods\n    const strainTolerance = (strainResilience + methodAffinity) / 2;\n\n    // Score based on whether method labor requirements match strain tolerance\n    let score: number;\n    if (methodHours <= 0.5) {\n      // Low labor methods work well with any strain\n      score = 0.9 + strainTolerance * 0.1;\n    } else if (methodHours <= 1.0) {\n      // Moderate labor methods need some strain tolerance\n      score = 0.6 + strainTolerance * 0.4;\n    } else {\n      // High labor methods need high strain tolerance\n      score = 0.2 + strainTolerance * 0.8;\n    }\n\n    return {\n      score: Math.max(0.1, Math.min(1.0, score)),\n      details: {\n        methodHours,\n        strainTolerance,\n      },\n    };\n  }\n\n  /**\n   * Calculate capacity fit based on method density vs strain characteristics\n   */\n  private calculateCapacityFit(\n    strain: EnhancedStrainBlueprint,\n    method: CultivationMethodBlueprint,\n  ): { score: number; details: { methodDensity: number; strainPreference: number } } {\n    const methodDensity = method.capacityHints?.plantsPer_m2 || 4;\n\n    // Estimate strain density preference based on genetics\n    const indicaRatio = strain.genotype.indica || 0.5;\n\n    // Indica strains generally prefer higher density (SOG), sativa prefers lower (SCROG)\n    const strainPreferredDensity = 2 + indicaRatio * 14; // Range: 2-16 plants/mÂ²\n\n    // Score based on how close method density is to strain preference\n    const densityDifference = Math.abs(methodDensity - strainPreferredDensity);\n    const maxDifference = 16; // Maximum reasonable difference\n\n    const score = Math.max(0.2, 1.0 - densityDifference / maxDifference);\n\n    return {\n      score,\n      details: {\n        methodDensity,\n        strainPreference: strainPreferredDensity,\n      },\n    };\n  }\n\n  /**\n   * Categorize compatibility score into buckets\n   */\n  private categorizeCompatibility(\n    score: number,\n  ): 'excellent' | 'good' | 'acceptable' | 'poor' | 'incompatible' {\n    if (score >= 0.85) return 'excellent';\n    if (score >= 0.7) return 'good';\n    if (score >= 0.5) return 'acceptable';\n    if (score >= 0.3) return 'poor';\n    return 'incompatible';\n  }\n\n  /**\n   * Get compatibility recommendations based on the analysis\n   */\n  getRecommendations(result: MethodCompatibilityResult): string[] {\n    const recommendations: string[] = [];\n\n    if (result.environmentalFit < 0.6) {\n      recommendations.push('Consider environmental adjustments to better match strain preferences');\n    }\n\n    if (result.laborFit < 0.6) {\n      recommendations.push('This method may require more labor than optimal for this strain');\n    }\n\n    if (result.capacityFit < 0.6) {\n      recommendations.push('Plant density may not be ideal for this strain type');\n    }\n\n    if (result.category === 'excellent') {\n      recommendations.push('Excellent match - this method is ideal for this strain');\n    } else if (result.category === 'incompatible') {\n      recommendations.push('Not recommended - consider alternative cultivation methods');\n    }\n\n    return recommendations;\n  }\n}\n\n// Export singleton instance\nexport const methodCompatibilityService = new MethodCompatibilityService();